\page ParameterSystem The Parameter System

The `elke` input parameter system is quite complex as it uses the latest and
greatest of C++ template technology. It is debatable whether one should explain
this from a bottom-up approach or a top-down approach, however, for this page
we will use a top-down approach.

# 1 The high level objects
The two main players in the parameter system are:
- `elke::DataTree`, and
- `elke::InputParametersBlock`

## 1.1 The DataTree class
An `elke::DataTree` normally gets created from an input file like a json or 
yaml formatted file (see `elke::YAMLInput`), although it can be manually created as well. The nature of 
the `elke::DataTree` uses an internal dependency to represent the branches of the
data-tree. In other words, an `elke::DataTree` can have connections to other
"child" data-trees also of the class type `elke::DataTree`. The schematic below 
shows how a DataTree can be constructed where only the "leaf" items have an 
actual value.

```
                         DataTree
                            |
                        ----*----
                        |        |
                    DataTree  DataTree ---- DataTree
                (Leaf/Scalar))    |         (Leaf/Scalar)
                                  |
                              DataTree
                              (Leaf/Scalar)
```
DataTree can be any of the following:
- `DataGrossType::NO_DATA`, e.g. `scale: Null`
- `DataGrossType::SCALAR`, e.g. `scale: 1.2`
- `DataGrossType::SEQUENCE`, e.g. `scales: [1, 2, 3]`
- `DataGrossType::MAP`, e.g. `scales: {scalex: 1.1, scaley: 1.2}`


## 1.2 The InputParameterBlock class
An `InputParametersBlock` object is designed to provide a standardized method
to add, check and retrieve input parameters. A block has a number of parameters
of different types all based off `elke::InputParameter`. The different types
include (at the time of writing this documentation):
- Scalar based input-parameters:
  - `elke::ScalarInputParameter`, single parameter, with a `elke::ScalarValue` type
  - `elke::VectorOfScalarsInputParameter`, a vector, i.e., `std::vector<ScalarValue>`
- Parameters based off other "named" input-blocks:
  - `elke::NamedBlockInputParameter`, where a named block is "registered" and 
    can be reused by other object. Imagine 5 different types of objects all needing
    "volume" and "area" parameters. Reusable code can be generated by lumping these
    parameters into a named-block and registering it using `elkeRegisterInputBlock`.
    Example:
```c++
struct TestNamedBlock
{
  static InputParametersBlock getInputParameters()
  {
    auto params = InputParametersBlock(/*name=       */ "TestNamedBlock",
                                       /*description=*/"No description");
    params.addOptionalParameter("volume", 1.0, "Volume of the volume.");
    params.addOptionalParameter("area", 1.0, "Area of the volume.");
  
    return params;
  }
};
  
elkeRegisterInputBlock(TestNamedBlock);

//Using the block
parameters = InputParametersBlock(/*name=       */ "Reused",
                                  /*description=*/ "No description");
parameters.addOptionalParameter("scale", 1.0, "The Scale of the object.");
parameters.addParameterAsNamedInputBlock(/*name=           */ "geometry",
                                         /*description=    */ "Component geometry info",
                                         /*parameter_class=*/ ParameterClass::OPTIONAL,
                                         /*block_name      */ "TestNamedBlock");
```
  - `elke::VectorOfNamedBlocksInputParameter`, almost the same as the single variant
    but allows the block to accept multiple entries all for the same block name.
  - `elke::FixedVectorOfNamedBlocksInputParameter`, allows the block to accepts a fixed
    amount of named blocks, with each block name customizable.
  - `elke::MapOfNamedBlocksInputParameter` Same as the vector variant but the entries
    need to be arranged according to a map.
- Parameters used to construct factory-objects (requires the "type" string entry):
  - `elke::RegisteredObjectInputParameter`, will cause the code to look whether
    an object is registered for the `type` parameter.
    Example:
```c++
parameters.addOptionalParameter(/*name */       "sub_object", 
                                /*value*/       RegisteredObjectProxy(), 
                                /*description*/ "Factory object entry");
```
  - `elke::VectorOfRegisteredObjectsInputParameter`, will require a vector object 
    entries.
  - `elke::MapOfRegisteredObjectsInputParameter`, will require a map of object entries.
    This is the most common use of RegisterObjectProxy.

# 2 Factory Objects
The automated creation of objects is done by means of `elke::SyntaxBlock` type
objects. A factory-constructible object, e.g. "TestObject" has 3 primary requirements,
- In needs to derive from `elke::FactoryObject`,
- It must implement the static method `InputParametersBlock getInputParameters()`, and
- It's constructor must have the signature `TestObject(const InputParametersBlock& params)`
Example:
```c++
class TestObject : public FactorObject
{
public:
  static InputParametersBlock getInputParameters();

  explicit FactoryObject(const InputParametersBlock& params);
};
```